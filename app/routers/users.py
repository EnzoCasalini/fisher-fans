# generated by fastapi-codegen:
#   filename:  FF_API.yaml
#   timestamp: 2024-11-22T13:36:24+00:00

from __future__ import annotations

import uuid
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.models import UserRead as PydanticUser
from app.models_sqlalchemy import User as SQLAlchemyUser
from app.models_sqlalchemy import Reservation as SQLAlchemyReservation
from app.models_sqlalchemy import Boat as SQLAlchemyBoat
from app.models_sqlalchemy import Trip as SQLAlchemyTrip
from app.models_sqlalchemy import Log as SQLAlchemyLog
from app.models_sqlalchemy import Page as SQLAlchemyPage  # ✅ Import des pages du log

from ..dependencies import *

router = APIRouter(tags=['Users'])


@router.get(
    '/v1/users',
    response_model=List[PydanticUser],
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '404': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Users'],
)
def get_users(
    company: Optional[str] = None,
    skip: int = 0,
    limit: int = 10,
    db: Session = Depends(get_db),
) -> list[PydanticUser]:
    """
    Récupère une liste d'utilisateurs avec leurs bateaux, trips, réservations et leur log de pêche.
    """
    query = db.query(SQLAlchemyUser)
    if company:
        query = query.filter(SQLAlchemyUser.companyName.ilike(f"%{company}%"))

    users = query.offset(skip).limit(limit).all()

    result = []
    for user in users:
        user_dict = user.__dict__.copy()
        user_dict['id'] = str(user.id)

        # Ajout des bateaux
        user_dict["boats"] = [
            {
                "id": boat.id,
                "name": boat.name,
                "brand": boat.brand,
                "homePort": boat.homePort,
            }
            for boat in user.boats
        ] if user.boats else None

        # Ajout des trips
        user_dict["trips"] = [
            {
                "id": trip.id,
                "title": trip.title,
                "tripType": trip.tripType,
                "price": trip.price,
            }
            for trip in user.trips
        ] if user.trips else None

        # Ajout des réservations (avec uniquement `tripId`)
        user_dict["reservations"] = [
            {
                "id": res.id,
                "tripId": res.tripId,
                "date": res.date,
                "reservedSeats": res.reservedSeats,
                "totalPrice": res.totalPrice,
                "userId": res.userId,
            }
            for res in user.reservations
        ]

        # Ajout des pages du log de pêche
        user_dict["log"] = {
            "id": user.log[0].id,  # On suppose que l'utilisateur n'a qu'un seul log
            "pages": [
                {
                    "id": page.id,
                    "fish_name": page.fish_name,
                    "photo_url": page.photo_url,
                    "comment": page.comment,
                    "size_cm": page.size_cm,
                    "weight_kg": page.weight_kg,
                    "location": page.location,
                    "dateOfCatch": page.dateOfCatch,
                    "released": page.released,
                }
                for page in user.log[0].pages  # ✅ Accéder uniquement au premier log
            ]
        } if user.log else None

        result.append(PydanticUser(**user_dict))

    return result


@router.get(
    '/v1/users/{user_id}',
    response_model=PydanticUser,
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '404': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Users'],
)
def get_user(user_id: str, db: Session = Depends(get_db)) -> PydanticUser:
    """
    Récupère un utilisateur par son ID avec ses bateaux, trips, réservations et son log de pêche.
    """
    user = db.query(SQLAlchemyUser).filter(SQLAlchemyUser.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    user_dict = user.__dict__.copy()
    user_dict['id'] = str(user.id)

    # Ajout des bateaux
    user_dict["boats"] = [
        {
            "id": boat.id,
            "name": boat.name,
            "brand": boat.brand,
            "homePort": boat.homePort,
        }
        for boat in user.boats
    ] if user.boats else None

    # Ajout des trips
    user_dict["trips"] = [
        {
            "id": trip.id,
            "title": trip.title,
            "tripType": trip.tripType,
            "price": trip.price,
        }
        for trip in user.trips
    ] if user.trips else None

    # Ajout des réservations (avec uniquement `tripId`)
    user_dict["reservations"] = [
        {
            "id": res.id,
            "tripId": res.tripId,
            "date": res.date,
            "reservedSeats": res.reservedSeats,
            "totalPrice": res.totalPrice,
            "userId": res.userId,
        }
        for res in user.reservations
    ]

    # Ajout des pages du log de pêche
    user_dict["log"] = {
        "id": user.log[0].id,  # On suppose que l'utilisateur n'a qu'un seul log
        "pages": [
            {
                "id": page.id,
                "fish_name": page.fish_name,
                "photo_url": page.photo_url,
                "comment": page.comment,
                "size_cm": page.size_cm,
                "weight_kg": page.weight_kg,
                "location": page.location,
                "dateOfCatch": page.dateOfCatch,
                "released": page.released,
            }
            for page in user.log[0].pages  # ✅ Accéder uniquement au premier log
        ]
    } if user.log else None

    return PydanticUser(**user_dict)


@router.post(
    '/v1/users',
    response_model=PydanticUser,
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Users'],
)
def create_user(user: PydanticUser, db: Session = Depends(get_db)) -> PydanticUser:
    """
    Crée un nouvel utilisateur.
    """
    if not user.id:
        user.id = str(uuid.uuid4())

    db_user = SQLAlchemyUser(**user.dict())
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return PydanticUser.from_orm(db_user)


@router.put(
    '/v1/users/{user_id}',
    response_model=PydanticUser,
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '404': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Users'],
)
def update_user(user_id: str, updated_user: PydanticUser, db: Session = Depends(get_db)) -> PydanticUser:
    """
    Met à jour les informations d'un utilisateur spécifique par son ID.
    """
    user = db.query(SQLAlchemyUser).filter(SQLAlchemyUser.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    for key, value in updated_user.dict(exclude_unset=True).items():
        setattr(user, key, value)

    db.commit()
    db.refresh(user)
    return PydanticUser.from_orm(user)


@router.delete(
    '/v1/users/{user_id}',
    response_model=None,
    tags=['Users'],
)
def delete_user(user_id: str, db: Session = Depends(get_db)) -> None:
    """
    Supprime un utilisateur spécifique par son ID.
    """
    user = db.query(SQLAlchemyUser).filter(SQLAlchemyUser.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    if user.reservations:
        raise HTTPException(status_code=409, detail="Cannot delete user with active reservations.")

    db.delete(user)
    db.commit()
    return None