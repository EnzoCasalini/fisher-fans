# generated by fastapi-codegen:
#   filename:  FF_API.yaml
#   timestamp: 2024-11-22T13:36:24+00:00

from __future__ import annotations

import datetime
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, Path

import uuid
from app.models import Reservation as PydanticReservation
from app.models_sqlalchemy import Reservation as SQLAlchemyReservation
from app.models_sqlalchemy import Trip as SQLAlchemyTrip
from app.models_sqlalchemy import User as SQLAlchemyUser

from datetime import date
from ..dependencies import *


router = APIRouter(tags=['Reservations'])


@router.get(
    '/v1/reservations',
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '404': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Reservations'],
)
def get_reservations(db: Session = Depends(get_db)):
    """
    Get the list of reservations with only the tripId
    """
    reservations = db.query(SQLAlchemyReservation).all()

    return [
        {
            "id": res.id,
            "tripId": res.tripId,  # ✅ Ne retourne que l'ID du trip
            "date": res.date,
            "reservedSeats": res.reservedSeats,
            "totalPrice": res.totalPrice,
            "userId": res.userId,
        }
        for res in reservations
    ]


@router.post(
    '/v1/reservations',
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '422': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Reservations'],
)
def create_reservation(reservation: PydanticReservation, db: Session = Depends(get_db)):
    """
    Create a new reservation
    """
    if not reservation.id:
        reservation.id = str(uuid.uuid4())

    trip = db.query(SQLAlchemyTrip).filter(SQLAlchemyTrip.id == reservation.trip.id).first() if reservation.trip else None
    if reservation.trip and not trip:
        raise HTTPException(status_code=400, detail="Trip does not exist")

    user = db.query(SQLAlchemyUser).filter(SQLAlchemyUser.id == reservation.userId).first()
    if not user:
        raise HTTPException(status_code=400, detail="User does not exist")

    new_reservation = SQLAlchemyReservation(
        id=reservation.id,
        tripId=trip.id if trip else None,  # ✅ Stocke uniquement l'ID du trip
        date=reservation.date or datetime.utcnow(),
        reservedSeats=reservation.reservedSeats,
        totalPrice=reservation.totalPrice,
        userId=reservation.userId,
    )
    db.add(new_reservation)
    db.commit()
    db.refresh(new_reservation)

    return {
        "id": new_reservation.id,
        "tripId": new_reservation.tripId,  # ✅ Retourne uniquement l'ID
        "date": new_reservation.date,
        "reservedSeats": new_reservation.reservedSeats,
        "totalPrice": new_reservation.totalPrice,
        "userId": new_reservation.userId,
    }


@router.get(
    '/v1/reservations/{reservation_id}',
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '404': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Reservations'],
)
def get_reservation(reservation_id: str, db: Session = Depends(get_db)):
    """
    Get a reservation by ID with only the tripId
    """
    reservation = db.query(SQLAlchemyReservation).filter(SQLAlchemyReservation.id == reservation_id).first()
    if not reservation:
        raise HTTPException(status_code=404, detail="Reservation not found")

    return {
        "id": reservation.id,
        "tripId": reservation.tripId,  # ✅ Retourne uniquement l'ID du trip
        "date": reservation.date,
        "reservedSeats": reservation.reservedSeats,
        "totalPrice": reservation.totalPrice,
        "userId": reservation.userId,
    }


@router.put(
    '/v1/reservations/{reservation_id}',
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '404': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Reservations'],
)
def update_reservation(reservation_id: str, updated_reservation: PydanticReservation, db: Session = Depends(get_db)):
    """
    Edit a reservation
    """
    reservation = db.query(SQLAlchemyReservation).filter(SQLAlchemyReservation.id == reservation_id).first()
    if not reservation:
        raise HTTPException(status_code=404, detail="Reservation not found")

    reservation.tripId = updated_reservation.trip.id if updated_reservation.trip else None
    reservation.date = updated_reservation.date or reservation.date
    reservation.reservedSeats = updated_reservation.reservedSeats
    reservation.totalPrice = updated_reservation.totalPrice
    reservation.userId = updated_reservation.userId

    db.commit()
    db.refresh(reservation)
    return {
        "id": reservation.id,
        "tripId": reservation.tripId,  # ✅ Retourne uniquement l'ID du trip
        "date": reservation.date,
        "reservedSeats": reservation.reservedSeats,
        "totalPrice": reservation.totalPrice,
        "userId": reservation.userId,
    }


@router.delete(
    '/v1/reservations/{reservation_id}',
    response_model=None,
    responses={
        '400': {'model': Error},
        '401': {'model': Error},
        '403': {'model': Error},
        '404': {'model': Error},
        '500': {'model': Error},
    },
    tags=['Reservations'],
)
def delete_reservation(reservation_id: str, db: Session = Depends(get_db)):
    """
    Delete a reservation
    """
    reservation = db.query(SQLAlchemyReservation).filter(SQLAlchemyReservation.id == reservation_id).first()
    if not reservation:
        raise HTTPException(status_code=404, detail="Reservation not found")

    db.delete(reservation)
    db.commit()
    return {"message": "Reservation deleted successfully"}